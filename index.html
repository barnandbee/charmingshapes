<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Charming Shapes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@700&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Nunito', sans-serif;
            transition: background-color 0.5s ease;
            overflow-y: auto;
            overflow-x: hidden;
            background-color: #fff1f2; /* Default bg */
        }
        canvas {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            transition: border-color 0.5s ease;
            display: block; /* Fix canvas display issues */
        }
        .font-comfortaa {
            font-family: 'Comfortaa', cursive;
        }
        .touch-control {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: rgba(99, 102, 241, 0.6);
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
            z-index: 40; /* Ensure above canvas */
        }
        .touch-control:active {
            background-color: rgba(79, 70, 229, 0.8);
        }
        #initialsInput {
            text-transform: uppercase;
        }
        #levelUpNotice {
            transition: opacity 0.5s ease-in-out;
        }
        button {
            cursor: pointer;
            position: relative; 
            z-index: 50;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 bg-rose-50">

    <h1 class="font-comfortaa text-4xl md:text-5xl font-bold text-indigo-500 mb-4 text-center">Charming Shapes</h1>

    <!-- Game Container -->
    <div id="game-container" class="w-full max-w-3xl aspect-square relative flex items-center justify-center">
        <canvas id="gameCanvas"></canvas>
        
        <div id="levelUpNotice" class="absolute inset-0 flex items-center justify-center text-6xl font-comfortaa text-yellow-400 font-bold opacity-0 pointer-events-none" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 60;">
            Level Up!
        </div>

        <!-- Touch Controls Overlay -->
        <div id="touchControlsContainer" class="hidden absolute inset-0 z-40">
            <div id="touch-up" class="touch-control top-4 left-1/2 -translate-x-1/2"></div>
            <div id="touch-down" class="touch-control bottom-4 left-1/2 -translate-x-1/2"></div>
            <div id="touch-left" class="touch-control left-4 top-1/2 -translate-y-1/2"></div>
            <div id="touch-right" class="touch-control right-4 top-1/2 -translate-y-1/2"></div>
        </div>

        <!-- Game Over / Menu Modal -->
        <div id="gameOverModal" class="hidden absolute inset-0 bg-black bg-opacity-70 flex-col items-center justify-center rounded-xl p-4 z-50">
            <h2 class="font-comfortaa text-5xl font-bold text-red-500 text-center">Game Over</h2>
            <p class="text-xl mt-2 text-white">Final Score: <span id="finalScore" class="font-bold text-yellow-300">0</span></p>
            
            <div id="highScoreEntry" class="hidden flex-col items-center mt-4 w-full">
                 <p class="text-lg text-white text-center">You're a Shape Legend! Enter initials:</p>
                 <input type="text" id="initialsInput" maxlength="3" class="mt-2 text-center font-comfortaa text-2xl p-2 rounded-md w-24 bg-gray-200 text-gray-800">
                 <button id="saveScoreButton" class="mt-3 px-5 py-2 bg-green-500 hover:bg-green-600 text-white font-bold rounded-lg shadow-md">Save Score</button>
            </div>

            <div id="shapeLegends" class="mt-4 text-white w-full max-w-xs">
                <h3 class="font-comfortaa text-2xl text-center text-cyan-300">Shape Legends</h3>
                <ol id="highScoreList" class="mt-2 space-y-1 list-decimal list-inside text-center"></ol>
            </div>

            <button id="restartButton" class="mt-6 px-6 py-3 bg-indigo-500 hover:bg-indigo-600 text-white font-bold rounded-lg shadow-lg transition-transform transform hover:scale-105">
                Play Again
            </button>
        </div>
    </div>

    <!-- Controls and Stats -->
    <div class="w-full max-w-3xl mt-4 relative z-50">
        <div id="controls" class="flex justify-center items-center gap-4 mb-4 flex-wrap">
             <button id="easyButton" class="px-8 py-4 bg-green-500 hover:bg-green-600 text-white font-bold rounded-lg shadow-lg transition-transform transform hover:scale-105 text-xl">
                Easy Mode
            </button>
            <button id="hardButton" class="px-8 py-4 bg-red-500 hover:bg-red-600 text-white font-bold rounded-lg shadow-lg transition-transform transform hover:scale-105 text-xl">
                Hard Mode
            </button>
        </div>
        
        <div id="gameInfo" class="hidden items-center grid grid-cols-3 md:grid-cols-6 gap-2 md:gap-4 text-center bg-white/80 backdrop-blur-sm p-2 md:p-4 rounded-lg border border-indigo-100 shadow-sm">
            <div><p class="text-xs md:text-sm text-indigo-400 uppercase tracking-wider font-semibold">Level</p><p id="levelDisplay" class="font-comfortaa text-xl md:text-2xl font-bold">1</p></div>
            <div><p class="text-xs md:text-sm text-indigo-400 uppercase tracking-wider font-semibold">Time</p><p id="timeDisplay" class="font-comfortaa text-xl md:text-2xl font-bold">0s</p></div>
            <div><p class="text-xs md:text-sm text-indigo-400 uppercase tracking-wider font-semibold">Score</p><p id="scoreDisplay" class="font-comfortaa text-xl md:text-2xl font-bold">0</p></div>
            <div><p class="text-xs md:text-sm text-indigo-400 uppercase tracking-wider font-semibold">Player</p><p id="playerSidesDisplay" class="font-comfortaa text-xl md:text-2xl font-bold">4</p></div>
            <div><p class="text-xs md:text-sm text-indigo-400 uppercase tracking-wider font-semibold">Border</p><p id="outerSidesDisplay" class="font-comfortaa text-xl md:text-2xl font-bold">4</p></div>
            <div class="flex justify-center items-center h-full">
                <button id="muteButton" class="p-2 rounded-full bg-indigo-200 hover:bg-indigo-300 text-indigo-600 transition-colors">
                    <svg id="volume-on" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /></svg>
                    <svg id="volume-off" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 14l2-2m0 0l2-2m-2 2l-2 2m2-2l2 2" /></svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const easyButton = document.getElementById('easyButton');
        const hardButton = document.getElementById('hardButton');
        const restartButton = document.getElementById('restartButton');
        const muteButton = document.getElementById('muteButton');
        const gameOverModal = document.getElementById('gameOverModal');
        const gameInfo = document.getElementById('gameInfo');
        const controls = document.getElementById('controls');
        const touchControlsContainer = document.getElementById('touchControlsContainer');
        const highScoreEntry = document.getElementById('highScoreEntry');
        const saveScoreButton = document.getElementById('saveScoreButton');
        const initialsInput = document.getElementById('initialsInput');
        const highScoreList = document.getElementById('highScoreList');
        const levelUpNotice = document.getElementById('levelUpNotice');
        const body = document.body;

        // --- Game Config ---
        const MAX_SIDES = 20;
        const LEVEL_COLORS = [
            { name: '1', bgColor: '#fdf2f8', pColor: '#f472b6', bColor: '#a5b4fc', inverted: false },
            { name: '2', bgColor: '#f0fdf4', pColor: '#4ade80', bColor: '#2dd4bf', inverted: false },
            { name: '3', bgColor: '#fefce8', pColor: '#facc15', bColor: '#fb923c', inverted: false },
            { name: '4', bgColor: '#f5f3ff', pColor: '#a78bfa', bColor: '#f472b6', inverted: false },
            { name: '5', bgColor: '#fff1f2', pColor: '#fb7185', bColor: '#e11d48', inverted: false },
            { name: 'Z', bgColor: '#1f2937', pColor: '#f9fafb', bColor: '#9ca3af', inverted: true }
        ];
        const EASY_THRESHOLDS = [0, 300, 1000, 3000, 6666, 10000];
        const HARD_THRESHOLDS = [0, 1000, 10000, 100000, 1000000, 1000000000];
        
        // --- Game State ---
        let player, outerShape, gameState, gameTimer, music, backgroundShapes = [], highScores = [];
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        let animationFrameId;

        // --- High Score Functions ---
        const getHighScores = () => { highScores = JSON.parse(localStorage.getItem('shapeLegendsScores') || '[]'); };
        const saveHighScores = () => { localStorage.setItem('shapeLegendsScores', JSON.stringify(highScores)); };

        function displayHighScores() {
            highScoreList.innerHTML = highScores.length ? '' : '<li class="text-center text-gray-400">Be the first legend!</li>';
            highScores.forEach(score => {
                const li = document.createElement('li');
                li.className = 'flex justify-between font-mono';
                li.innerHTML = `<span>${score.initials}</span><span class="text-yellow-300">${score.score}</span>`;
                highScoreList.appendChild(li);
            });
        }

        const checkIfHighScore = (score) => highScores.length < 5 || score > highScores[highScores.length - 1].score;

        // --- Utility Functions ---
        const getSideValue = (currentSides) => {
            if (currentSides >= MAX_SIDES) return [-3, -2, -1][Math.floor(Math.random() * 3)];
            return [-3, -2, -1, 1, 2, 3, 'M'][Math.floor(Math.random() * 7)];
        };
        const getRandomColor = () => `hsl(${Math.random() * 360}, 70%, 80%)`;
        
        const resizeCanvas = () => {
            const container = document.getElementById('game-container');
            // Ensure container has width before calculating
            if (container.clientWidth === 0) return;
            
            const size = Math.min(container.clientWidth, window.innerHeight * 0.65);
            canvas.width = size;
            canvas.height = size;
            
            // Force redraw if game is idle/menu
            if (backgroundShapes.length > 0 && (!gameState || !gameState.isStarted)) {
                 ctx.clearRect(0, 0, canvas.width, canvas.height);
                 updateAndDrawBackground();
            }
        };

        // --- Music ---
        function setupMusic() {
            if (typeof Tone === 'undefined') return;
            try {
                music = { synth: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } }).toDestination() };
                const melody = [{ time: '0:0', note: 'C4', duration: '8n' }, { time: '0:1', note: 'E4', duration: '8n' }, { time: '0:2', note: 'G4', duration: '8n' }, { time: '0:3', note: 'C5', duration: '8n' }];
                music.sequence = new Tone.Sequence((time, value) => music.synth.triggerAttackRelease(value.note, value.duration, time), melody, '4n').start(0);
                Tone.Transport.bpm.value = 140;
            } catch (e) { console.warn("Audio init failed", e); }
        }

        // --- Background ---
        function initBackgroundShapes() {
            backgroundShapes = Array.from({ length: 30 }, () => ({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 10 + 5, sides: Math.floor(Math.random() * 5) + 3, speed: Math.random() * 0.5 + 0.2, color: getRandomColor(), rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.02 }));
        }

        function updateAndDrawBackground() {
            backgroundShapes.forEach(shape => {
                shape.y += shape.speed;
                shape.rotation += shape.rotationSpeed;
                if (shape.y > canvas.height + shape.radius) {
                    shape.y = -shape.radius;
                    shape.x = Math.random() * canvas.width;
                }
                ctx.globalAlpha = 0.5;
                drawPolygon(shape.x, shape.y, shape.radius, shape.sides, shape.color, shape.rotation);
                ctx.globalAlpha = 1.0;
            });
        }

        // --- Game Setup ---
        function startGame(mode) {
             const center = { x: canvas.width / 2, y: canvas.height / 2 };
            gameState = { time: 0, score: 0, hits: 0, isStarted: true, isOver: false, level: 0, mode: mode };
            player = { x: center.x, y: center.y, dx: 0, dy: 0, radius: 15, sides: 4, rotation: 0, rotationSpeed: 0.05, acceleration: 0.5 };
            outerShape = { x: center.x, y: center.y, radius: canvas.width / 2 - 20, sides: 4 };
            checkLevelUp(true); 
            outerShape.sideNumbers = Array.from({ length: 4 }, () => getSideValue(4));
            
            updateUI();
            gameOverModal.classList.add('hidden');
            gameOverModal.classList.remove('flex'); // Ensure flex is removed
            gameInfo.classList.remove('hidden');
            gameInfo.classList.add('grid');
            touchControlsContainer.classList.remove('hidden');
            controls.classList.add('hidden');
            controls.classList.remove('flex');

            clearInterval(gameTimer);
            gameTimer = setInterval(() => { gameState.time++; }, 1000);
            
            // Cancel existing loop if any to prevent double speed
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            masterLoop();
        }

        // --- Drawing ---
        function drawPolygon(x, y, radius, sides, color, rotation = 0) {
            if (sides < 1) return;
            ctx.beginPath();
            if (sides === 1) { ctx.arc(x, y, radius / 2, 0, Math.PI * 2); }
            else if (sides === 2) {
                const angle = rotation;
                ctx.moveTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
                ctx.lineTo(x + radius * Math.cos(angle + Math.PI), y + radius * Math.sin(angle + Math.PI));
            } else {
                const angleStep = (Math.PI * 2) / sides;
                ctx.moveTo(x + radius * Math.cos(rotation), y + radius * Math.sin(rotation));
                for (let i = 1; i <= sides; i++) {
                    const angle = i * angleStep + rotation;
                    ctx.lineTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
                }
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.lineJoin = 'round';
            ctx.stroke();
            ctx.fillStyle = `${color}33`;
            ctx.fill();
        }

        function drawOuterShape() {
            drawPolygon(outerShape.x, outerShape.y, outerShape.radius, outerShape.sides, outerShape.color);
            if (outerShape.sides >= 3) {
                const angleStep = (Math.PI * 2) / outerShape.sides;
                for (let i = 0; i < outerShape.sides; i++) {
                    const midAngle = (i * angleStep + (i + 1) * angleStep) / 2;
                    const textRadius = outerShape.radius + 18;
                    const textX = outerShape.x + textRadius * Math.cos(midAngle);
                    const textY = outerShape.y + textRadius * Math.sin(midAngle);
                    const sideValue = outerShape.sideNumbers[i];
                    ctx.font = 'bold 16px Nunito';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    if (sideValue === 'M') {
                        ctx.fillStyle = '#f59e0b';
                        ctx.fillText('M', textX, textY);
                    } else {
                        ctx.fillStyle = sideValue > 0 ? '#10b981' : '#f43f5e';
                        ctx.fillText(sideValue, textX, textY);
                    }
                }
            }
        }

        // --- Game Logic ---
        function movePlayer() {
            const currentLevel = LEVEL_COLORS[Math.min(gameState.level, LEVEL_COLORS.length - 1)];
            const is_inverted = currentLevel.inverted;

            if (keys.ArrowUp) player.dy += is_inverted ? player.acceleration : -player.acceleration;
            if (keys.ArrowDown) player.dy += is_inverted ? -player.acceleration : player.acceleration;
            if (keys.ArrowLeft) player.dx += is_inverted ? player.acceleration : -player.acceleration;
            if (keys.ArrowRight) player.dx += is_inverted ? -player.acceleration : player.acceleration;

            player.x += player.dx;
            player.y += player.dy;
            player.rotation += player.rotationSpeed;
        }

        function checkCollisions() {
            if (outerShape.sides < 3) return;
            const vertices = Array.from({ length: outerShape.sides }, (_, i) => {
                const angle = i * (Math.PI * 2) / outerShape.sides;
                return { x: outerShape.x + outerShape.radius * Math.cos(angle), y: outerShape.y + outerShape.radius * Math.sin(angle) };
            });
            for (let i = 0; i < vertices.length; i++) {
                const p1 = vertices[i], p2 = vertices[(i + 1) % vertices.length];
                const dx_edge = p2.x - p1.x, dy_edge = p2.y - p1.y;
                if (dx_edge === 0 && dy_edge === 0) continue;
                const lenSq = dx_edge * dx_edge + dy_edge * dy_edge;
                const t = ((player.x - p1.x) * dx_edge + (player.y - p1.y) * dy_edge) / lenSq;
                const clampedT = Math.max(0, Math.min(1, t));
                const closestPointX = p1.x + clampedT * dx_edge, closestPointY = p1.y + clampedT * dy_edge;
                const distSq = (player.x - closestPointX)**2 + (player.y - closestPointY)**2;
                if (distSq < player.radius**2) {
                    const dist = Math.sqrt(distSq);
                    const penetration = player.radius - dist;
                    let normalX = player.x - closestPointX, normalY = player.y - closestPointY;
                    const mag = Math.sqrt(normalX * normalX + normalY * normalY);
                    if (mag > 0) { normalX /= mag; normalY /= mag; }
                    else {
                        normalX = p2.y - p1.y; normalY = p1.x - p2.x;
                        const fallbackMag = Math.sqrt(normalX * normalX + normalY * normalY);
                        normalX /= fallbackMag; normalY /= fallbackMag;
                    }
                    handleCollision(i, normalX, normalY, penetration);
                    return;
                }
            }
        }

        function handleCollision(sideIndex, nx, ny, penetration) {
            player.x += nx * (penetration + 0.1);
            player.y += ny * (penetration + 0.1);
            const dotProduct = player.dx * nx + player.dy * ny;
            player.dx -= 2 * dotProduct * nx;
            player.dy -= 2 * dotProduct * ny;
            gameState.hits++;
            const sideValue = outerShape.sideNumbers[sideIndex];
            if (sideValue === 'M') {
                const newSides = Math.floor(Math.random() * MAX_SIDES) + 1;
                if (gameState.time % 2 === 0) { player.sides = newSides; }
                else {
                    outerShape.sides = newSides;
                    outerShape.sideNumbers = Array.from({ length: outerShape.sides }, () => getSideValue(outerShape.sides));
                }
            } else {
                if (gameState.time % 2 === 0) {
                    player.sides = Math.min(MAX_SIDES, Math.max(1, player.sides + sideValue));
                } else {
                    const oldSides = outerShape.sides;
                    outerShape.sides = Math.min(MAX_SIDES, Math.max(1, outerShape.sides + sideValue));
                    if (outerShape.sides !== oldSides) {
                        outerShape.sideNumbers = Array.from({ length: outerShape.sides }, () => getSideValue(outerShape.sides));
                    }
                }
            }
        }

        function checkLevelUp(force = false) {
            const thresholds = gameState.mode === 'easy' ? EASY_THRESHOLDS : HARD_THRESHOLDS;
            const newLevelIndex = thresholds.slice().reverse().findIndex(threshold => gameState.score >= threshold);
            const currentLevelIndex = thresholds.length - 1 - newLevelIndex;
            if (currentLevelIndex !== gameState.level || force) {
                if (!force && currentLevelIndex < LEVEL_COLORS.length) {
                    levelUpNotice.style.opacity = 1;
                    setTimeout(() => { levelUpNotice.style.opacity = 0; }, 1500);
                }
                gameState.level = currentLevelIndex;
                const levelConfig = LEVEL_COLORS[Math.min(currentLevelIndex, LEVEL_COLORS.length - 1)];
                player.color = levelConfig.pColor;
                outerShape.color = levelConfig.bColor;
                body.style.backgroundColor = levelConfig.bgColor;
                canvas.style.borderColor = levelConfig.bColor;
                updateTouchControlSVGs(levelConfig.inverted);
            }
        }

        function updateTouchControlSVGs(inverted) {
            const svgs = {
                up: '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" /></svg>',
                down: '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>',
                left: '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>',
                right: '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>'
            };
            document.getElementById('touch-up').innerHTML = inverted ? svgs.down : svgs.up;
            document.getElementById('touch-down').innerHTML = inverted ? svgs.up : svgs.down;
            document.getElementById('touch-left').innerHTML = inverted ? svgs.right : svgs.left;
            document.getElementById('touch-right').innerHTML = inverted ? svgs.left : svgs.right;
        }

        function checkOutOfBounds() {
            if (player.x - player.radius > canvas.width || player.x + player.radius < 0 || player.y - player.radius > canvas.height || player.y + player.radius < 0) {
                endGame();
            }
        }

        function endGame() {
            if (gameState.isOver) return;
            gameState.isOver = true;
            clearInterval(gameTimer);
            if (typeof Tone !== 'undefined' && Tone.Transport.state === 'started') Tone.Transport.stop();
            document.getElementById('finalScore').textContent = gameState.score;
            displayHighScores();
            if (checkIfHighScore(gameState.score)) {
                highScoreEntry.classList.remove('hidden');
                highScoreEntry.classList.add('flex');
                restartButton.classList.add('hidden');
            } else {
                highScoreEntry.classList.add('hidden');
                restartButton.classList.remove('hidden');
            }
            gameOverModal.classList.remove('hidden');
            gameOverModal.classList.add('flex');
            touchControlsContainer.classList.add('hidden');
        }

        function masterLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updateAndDrawBackground();
            if (gameState && gameState.isStarted && !gameState.isOver) {
                movePlayer();
                checkOutOfBounds();
                if (outerShape.sides >= 3) { checkCollisions(); }
                checkLevelUp();
                drawOuterShape();
                drawPolygon(player.x, player.y, player.radius, player.sides, player.color, player.rotation);
                gameState.score = gameState.time * gameState.hits;
                updateUI();
            }
            animationFrameId = requestAnimationFrame(masterLoop);
        }
        
        function updateUI() {
            if (!gameState) return;
            document.getElementById('levelDisplay').textContent = LEVEL_COLORS[Math.min(gameState.level, LEVEL_COLORS.length - 1)].name;
            document.getElementById('timeDisplay').textContent = `${gameState.time}s`;
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('playerSidesDisplay').textContent = player.sides;
            document.getElementById('outerSidesDisplay').textContent = outerShape.sides;
        }

        // --- Event Listeners ---
        function setupControlEvents() {
            window.addEventListener('keydown', (e) => { if (e.key in keys) { e.preventDefault(); keys[e.key] = true; } });
            window.addEventListener('keyup', (e) => { if (e.key in keys) { e.preventDefault(); keys[e.key] = false; } });
            const touchMap = { 'touch-up': 'ArrowUp', 'touch-down': 'ArrowDown', 'touch-left': 'ArrowLeft', 'touch-right': 'ArrowRight' };
            for (const [id, key] of Object.entries(touchMap)) {
                const btn = document.getElementById(id);
                const setKey = (val) => (e) => { e.preventDefault(); keys[key] = val; };
                btn.addEventListener('mousedown', setKey(true)); btn.addEventListener('mouseup', setKey(false));
                btn.addEventListener('mouseleave', setKey(false)); btn.addEventListener('touchstart', setKey(true));
                btn.addEventListener('touchend', setKey(false));
            }
        }

        async function handleStart(mode) {
            if (typeof Tone !== 'undefined') {
                try {
                    await Tone.start();
                    if (Tone.Transport.state !== 'started') Tone.Transport.start();
                } catch (e) { console.warn("Tone start failed", e); }
            }
            startGame(mode);
        }

        // Initialize once DOM is ready
        window.onload = () => {
            easyButton.addEventListener('click', () => handleStart('easy'));
            hardButton.addEventListener('click', () => handleStart('hard'));

            restartButton.addEventListener('click', () => {
                 if (typeof Tone !== 'undefined' && Tone.Transport.state !== 'started') Tone.Transport.start();
                 gameOverModal.classList.add('hidden');
                 gameOverModal.classList.remove('flex');
                 controls.classList.remove('hidden');
                 controls.classList.add('flex');
                 gameInfo.classList.add('hidden');
                 gameInfo.classList.remove('grid');
            });

            saveScoreButton.addEventListener('click', () => {
                const initials = initialsInput.value.trim().toUpperCase() || '???';
                highScores.push({ initials: initials, score: gameState.score });
                highScores.sort((a, b) => b.score - a.score);
                highScores = highScores.slice(0, 5);
                saveHighScores();
                displayHighScores();
                highScoreEntry.classList.add('hidden');
                highScoreEntry.classList.remove('flex');
                restartButton.classList.remove('hidden');
            });
            
            muteButton.addEventListener('click', () => {
                if (typeof Tone !== 'undefined') {
                    Tone.Master.mute = !Tone.Master.mute;
                    document.getElementById('volume-on').classList.toggle('hidden', Tone.Master.mute);
                    document.getElementById('volume-off').classList.toggle('hidden', !Tone.Master.mute);
                }
            });

            window.addEventListener('resize', () => { resizeCanvas(); initBackgroundShapes(); });
            
            // Initial Setup
            getHighScores();
            resizeCanvas();
            setupMusic();
            setupControlEvents();
            initBackgroundShapes();
            
            // Start animation loop immediately for background
            masterLoop();
        };
    </script>
</body>
</html>
